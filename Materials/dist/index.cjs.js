"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var n=require("@gl-widget/gl-widget");exports.BlinnPhongMaterial=class{constructor(e={}){this.vertexShader="\n      attribute vec4 position;\n      attribute vec4 normal;\n      attribute vec2 uv                                                                                                                                                                                                                                                                                                                       ;\n      varying vec2 vUv;\n      varying vec4 vNormal;\n      varying vec4 vPosition;\n      uniform mat3 uvTransform;\n      uniform mat4 mvpMatrix;\n  \n      void main () {\n        gl_Position = mvpMatrix*position;\n        vPosition = gl_Position;\n        vNormal = normal;\n        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n      }\n    ",this.fragmentShader="\n      precision mediump float;\n      varying vec4 vPosition;\n      varying vec4 vNormal; \n      varying vec2 vUv;\n  \n      uniform vec3 globalAmbient; //入射环境光颜色\n      uniform vec3 lightColor; //灯光颜色\n      uniform vec3 lightPosition; //灯光的位置\n      uniform vec3 eyePosition;  //摄像机位置\n      uniform vec3 Ke;          //Ke是材质的放射光（自发光）颜色\n      uniform vec3 Ka;          //Ka是材质的环境反射系数\n      uniform vec3 Kd;          //Kd是材质的漫反射颜色\n      uniform vec3 Ks;          //Ks是材质的镜面反射颜色\n      uniform float shininess;     //材质表面光泽度\n      void main() {\n  \n        vec3 N = vNormal.xyz; \n        vec3 P = vPosition.xyz;\n  \n        //公式一计算放射光\n        vec3 emissive = Ke; \n        \n        //公式二计算环境光\n        vec3 ambient = Ka * globalAmbient;\n        \n        //公式三计算漫反射光\n        vec3 L = normalize (lightPosition - P); //L为标准化指向灯光的向量。\n        float diffuseLight = max(dot(N,L),0.0);   \n        vec3 diffuse = Kd * lightColor *diffuseLight;\n        \n        //公式四计算镜面放射\n        vec3 V = normalize(eyePosition - P);\n        vec3 H = normalize (L+V);\n        float specularLight = pow(max (dot (N,H),0.0), shininess);\n        if(dot(N,L) <= 0.0) {\n          specularLight = 0.0;\n        }\n            \n        vec3 specular = Ks * lightColor * specularLight ;\n        \n        // //基本光照模型完成\n        vec4 color;\n        color.xyz = emissive + ambient + diffuse + specular;\n        \n        color.w = 1.0;\n        gl_FragColor = color;\n      }\n    ",this.uniforms={globalAmbient:{value:e.ambient||new n.Vector3(0,0,0)},lightColor:{value:new n.Vector3(1,1,1)},lightPosition:{value:new n.Vector3(30,0,30)},eyePosition:{value:new n.Vector3(0,0,30)},Ke:{value:new n.Vector3(0,0,0)},Ka:{value:new n.Vector3(1,1,1)},Kd:{value:new n.Vector3(1,1,1)},Ks:{value:new n.Vector3(.1,.1,.1)},shininess:{value:32}}}},exports.TextureMaterial=class{constructor(e=null){this.transparent=!1,this.vertexShader="\n      attribute vec4 position;\n      attribute vec4 normal;\n      attribute vec2 uv;\n\n      varying vec2 vUv;\n      uniform mat4 mvpMatrix;\n      void main() {\n        vUv = uv;\n        gl_Position = mvpMatrix * vec4( position );\n      }\n    ",this.fragmentShader="\n      precision mediump float;\n      uniform sampler2D tDiffuse;\n      uniform float opacity;\n      varying vec2 vUv;\n      \n      void main() {\n\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n      }\n    ",this.uniforms={tDiffuse:{value:e},opacity:{value:1}},this.side=n.RenderSide.DOUBLE}};
//# sourceMappingURL=index.cjs.js.map
