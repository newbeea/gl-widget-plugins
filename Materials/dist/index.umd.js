!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@gl-widget/gl-widget")):"function"==typeof define&&define.amd?define(["exports","@gl-widget/gl-widget"],n):n((e=e||self).materials={},e.GLWidget)}(this,(function(e,n){"use strict";e.BlinnPhongMaterial=class{constructor(e={}){this.vertexShader="\n      attribute vec4 position;\n      attribute vec4 normal;\n      attribute vec2 uv                                                                                                                                                                                                                                                                                                                       ;\n      varying vec2 vUv;\n      varying vec4 vNormal;\n      varying vec4 vPosition;\n      uniform mat3 uvTransform;\n      uniform mat4 mvpMatrix;\n  \n      void main () {\n        gl_Position = mvpMatrix*position;\n        vPosition = gl_Position;\n        vNormal = normal;\n        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n      }\n    ",this.fragmentShader="\n      precision mediump float;\n      varying vec4 vPosition;\n      varying vec4 vNormal; \n      varying vec2 vUv;\n  \n      uniform vec3 globalAmbient; //入射环境光颜色\n      uniform vec3 lightColor; //灯光颜色\n      uniform vec3 lightPosition; //灯光的位置\n      uniform vec3 eyePosition;  //摄像机位置\n      uniform vec3 Ke;          //Ke是材质的放射光（自发光）颜色\n      uniform vec3 Ka;          //Ka是材质的环境反射系数\n      uniform vec3 Kd;          //Kd是材质的漫反射颜色\n      uniform vec3 Ks;          //Ks是材质的镜面反射颜色\n      uniform float shininess;     //材质表面光泽度\n      void main() {\n  \n        vec3 N = vNormal.xyz; \n        vec3 P = vPosition.xyz;\n  \n        //公式一计算放射光\n        vec3 emissive = Ke; \n        \n        //公式二计算环境光\n        vec3 ambient = Ka * globalAmbient;\n        \n        //公式三计算漫反射光\n        vec3 L = normalize (lightPosition - P); //L为标准化指向灯光的向量。\n        float diffuseLight = max(dot(N,L),0.0);   \n        vec3 diffuse = Kd * lightColor *diffuseLight;\n        \n        //公式四计算镜面放射\n        vec3 V = normalize(eyePosition - P);\n        vec3 H = normalize (L+V);\n        float specularLight = pow(max (dot (N,H),0.0), shininess);\n        if(dot(N,L) <= 0.0) {\n          specularLight = 0.0;\n        }\n            \n        vec3 specular = Ks * lightColor * specularLight ;\n        \n        // //基本光照模型完成\n        vec4 color;\n        color.xyz = emissive + ambient + diffuse + specular;\n        \n        color.w = 1.0;\n        gl_FragColor = color;\n      }\n    ",this.uniforms={globalAmbient:{value:e.ambient||new n.Vector3(0,0,0)},lightColor:{value:new n.Vector3(1,1,1)},lightPosition:{value:new n.Vector3(30,0,30)},eyePosition:{value:new n.Vector3(0,0,30)},Ke:{value:new n.Vector3(0,0,0)},Ka:{value:new n.Vector3(1,1,1)},Kd:{value:new n.Vector3(1,1,1)},Ks:{value:new n.Vector3(.1,.1,.1)},shininess:{value:32}}}},e.NoiseMaterial=class{constructor(){this.transparent=!1,this.fragmentShader="precision mediump float;\n#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}varying vec3 vPosition;void main(){float n=cnoise((vPosition.xy)*12.0);gl_FragColor=vec4(n,n,n,1.0);}",this.uniforms={},this.side=n.RenderSide.DOUBLE}},e.TextureMaterial=class{constructor(e=null){this.transparent=!1,this.vertexShader="\n      attribute vec4 position;\n      attribute vec4 normal;\n      attribute vec2 uv;\n\n      varying vec2 vUv;\n      uniform mat4 mvpMatrix;\n      void main() {\n        vUv = uv;\n        gl_Position = mvpMatrix * vec4( position );\n      }\n    ",this.fragmentShader="\n      precision mediump float;\n      uniform sampler2D tDiffuse;\n      uniform float opacity;\n      varying vec2 vUv;\n      \n      void main() {\n\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n      }\n    ",this.uniforms={tDiffuse:{value:e},opacity:{value:1}},this.side=n.RenderSide.DOUBLE}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
